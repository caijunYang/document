成都卓影科技终端平台java代码开发规约
============================================
# 一、编码规范
## 1.1 命名规范
* 代码中的命名均不能以下划线或美元符号开始或结束
      反例： _name / __name / $Object / name_ / name$ / Object$
* 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
      正例：  alibaba /  taobao /  youku /  hangzhou 等国际通用的名称，可视同英文。
      反例：  DaZhePromotion [ 打折 ] /  getPingfenByName() [ 评分 ] /  int 某变量 = 3
* 类名使用 UpperCamelCase 风格，必须遵从驼峰形式
      正例： MarcoPolo /  UserDO /  XmlService /  TcpUdpDeal /  TaPromotion
      反例： macroPolo /  UserDo /  XMLService /  TCPUDPDeal /  TAPromotion
* 方法名，参数名，变量名，统一使用使用lowerCamelCase 风格，必须遵从驼峰形式（常量除外）
      正例：  localValue /  getHttpMessage() /  inputUserId
* 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长，同类常量差异，尾部体现；
      正例：  MAX _ STOCK _ COUNT
      反例：  MAX _ COUNT
* 抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾；配置对象名统一以config或者configs结尾，工具类名统一以Utils结尾。
* 中括号是数组类型的一部分，数组定义如下： String[] args;
	    反例：使用 String args[] 的方式来定义
* POJO 类中布尔类型的变量，都不要加 is ，否则部分框架解析会引起序列化错误
	    反例：定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()
* 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用com.amt.服务名.父模块名.子模块名….pakageName， 配置包名统一为configs，工具包名统一util或utils
* 杜绝完全不规范的缩写，避免望文不知义
      正例：  ProductInfo
      反例：  ProdInfo
* 如果使用到了设计模式，建议在类名中体现出具体模式
      说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。
      正例： public class OrderFactory;
             public class LoginProxy;
             public class ResourceObserver;
* 接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量
* 接口和实现类的命名有统一在接口的实现类后面添加Impl
## 1.2	属性类型的定义
* 属性如果为正确/错误，是/否类属性，持久层Entity统一使用boolean类型进行定义（JPA使用Boolean），查询类对象可使用Boolean定义;应杜绝用1,0来表示
* 属性如果为多种类型，统一使用枚举类型进行定义，杜绝用不同的int，或者Integer来
## 1.3	常量的定义
* 代码中不允许使用任何魔法师（即未经定义的常量）直接出现在代码中
* long 或者 Long 初始赋值时，必须使用大写的 L，小写易造成误解（建议）
* 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类： CacheConsts 下 ； 系统配置相关的常量放在类： ConfigConsts 下
* 如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。
## 1.4	常量的定义
* 大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行 ； 如果是非空代码块则:
      1 ） 左大括号前不换行。
      2 ） 左大括号后换行。
      3 ） 右大括号前换行。
      4 ） 右大括号后还有 else 等代码则不换行 ； 表示终止的右大括号后必须换行
* 左小括号和字符之间不出现空格 ； 同样，右小括号和字符之间也不出现空格。
      反例： if (空格 a == b 空格)
* if / for / while / switch / do 等保留字与括号之间都必须加空格
* 任何二目、三目运算符的左右两边都需要加一个空格
* 缩进采用 4 个空格，禁止使用 tab 字符；如果要使用tab，那么请将1个tab设置为4个空格
* 单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：
```java
  1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。
  2 ） 运算符与下文一起换行。
  3 ） 方法调用的点符号与下文一起换行。
  4 ） 在多个参数超长，在逗号后换行。
  5 ） 在括号前不要换行。
  正例：
      StringBuffer sb = new StringBuffer();
      //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行
      sb.append("zi").append("xin")...
      .append("huang")...
      .append("huang")...
      .append("huang");
```
* 数据封装，除非使用范围很小，否则不建议直接使用Map进行数据封装，统一应定义对应的对象类来进行数据封装
* 数据封装，如果多个数据封装对象有共享字段，充分利用对象的继承，进行上层对象抽取，体现出封装的层次结构
* 单个方法的代码行数进行控制，不宜过多（不超过一屏），造成不必要的阅读困难

## 1.5	OOP规约
* 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。
* 所有的覆写方法，必须加@ Override 注解
* 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@ Deprecated 注解，并清晰地说明采用的新接口或者新服务，建议不使用过时的类或方法
* equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals
* 包装类的比较，统一用equals
* 定义 Do / Dto / Vo 等 POJO 类时，不要设定任何属性默认值
* 序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败 ； 如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值
* 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中（建议）
* POJO 类如果写 toString 方法。如果继承了另一个 POJO 类，注意在前面加一下 super .toString（建议）
* 使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险
    ```java
     说明
        String str = "a,b,c,,";
        String[] ary = str.split(",");
        //预期大于 3，结果是 3
    ```
* 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。
* setter 方法中，参数名称与类成员变量名称一致， this .成员名 = 参数名。在getter / setter 方法中，不要增加业务逻辑，增加排查问题的难度。
* 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展（线程安全时使用 StringBuffer）。
* final 可以声明类、成员变量、方法、以及本地变量.应该按要求使用（建议）

## 1.6	集合处理
* Set存贮对象必须重写equals和hashCode
* 使用自定义对象作为Map的KEY，那么自定义对象必须重写equals和hashCode
* ArrayList 的 subList 结果不可强转成 ArrayList ，否则会抛出 ClassCastException异常,subList是ArrayList内部类，所有操作都会作用到原列表上
* 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常
* 使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 list . size()，直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其它类型数组将出现 ClassCastException 错误
* 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关方法如果使用会抛出UnsupportedOperationException
* 在 JDK 7 版本及以上， Comparator 要满足如下三个条件，不然 Arrays . sort ，Collections.sort 会报 IllegalArgumentException 异常
	     说明：
          1 ） x ， y 的比较结果和 y ， x 的比较结果相反。
          2 ） x > y ， y > z ，则 x > z 。
          3 ） x = y ，则 x ， z 比较结果和 y ， z 比较结果相同
* 使entrySet遍历 Map 类集合 KV ，而不是 keySet 方式进行遍历,后再用key进行取值

## 1.7	并发处理
* 获取单例对象需要保证线程安全，其中的方法也要保证线程安全
* 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯
* 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
* SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static ，必须加锁，或者使用 DateUtils 工具类
* 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体 ； 能用对象锁，就不要用类锁
* 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁
* 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据
* 多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题

## 1.8	控制语句
* 在一个 switch 块内，每个 case 要么通过 break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止 ； 在一个 switch 块内，都必须包含一个 default语句并且放在最后，即使它什么代码也没有（建议）
* 在 if / else / for / while / do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式： if (condition) statements（建议）
* 表达异常的分支时，少用 if-else 方式 ，这种方式可以改写成：（建议）
    ```java
      if (condition) {
          ...
          return obj;
      }
    ```
// 接着写 else 的业务逻辑代码;
* 使用if()...else if()...else... ，避免后续代码出现维护困难，建议控制在3层以下
* 循环体中如果非必要，尽量避免在循环体中出现try – catch，建议try - catch放到循环体外

## 1.9	注释规约
* 类、类属性、类方法的注释必须使用 Javadoc 规范
* 所有的抽象方法 （ 包括接口中的方法 ） 必须要用 Javadoc 注释、除了返回值、参数、
异常说明外，还必须指出该方法做什么事情，实现什么功能
* 所有的类都必须添加创建者和创建日期
* 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* 内容*/注释，注意与代码对齐
* 所有的枚举类型字段必须要有注释，说明每个数据项的用途
* 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改
## 1.10	接口
* 接口数据传输，超过5个参数的方法，统一定义数据传输对象
* 对外接口或对前端界面的接口，返回层数据统一定义为对象
* 与客户端对接接口，如果参数不多，统一采用普通Get方式，不建议采用JSON，普通GET效率更高

## 1.11	其他
* 注意  Math . random() 这个方法返回是 double 类型，注意取值的范围 0≤ x <1 （ 能够取到零值，注意除零异常 ） ，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法
* 获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();
* 于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾

# 2	异常与日志
## 2.1	异常处理
* java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，如NullPointerException，IndexOutOfBoundsException等
* 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低
* 对大段代码进行 try - catch ，这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理
* 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容
* 有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务
* finally 块必须对资源对象、流对象进行关闭，有异常也要做 try - catch
* 不能在 finally 块中使用 return ， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句
* 捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类
## 2.2	日志
* 应用中不可直接使用日志系统 （Log 4 j 、 Logback） 中的 API ，而应依赖使用日志框架SLF 4 J 中的 API ，使用统一模式的日志框架，有利于维护和各个类的日志处理方式统一
* 对 trace / debug / info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式
* 避免重复打印日志，浪费磁盘空间，务必在 log 4 j . xml 中设置 additivity = false
* 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出
* 日志应具备关键信息，如用户订单，则必须明确记录用户账号，对应的订单号等信息

# 3	MYSQL数据库规约
## 3.1	建表规约
* 表名命名应该是“业务名称_表的作用”规则，如权限表,权限属于系统业务，则应该命名为system_permission或sys_permission
* 表名、字段名必须使用小写字母或数字 ， 禁止出现数字开头，禁止两个下划线中间只
出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑
* 表名不使用复数名词
* 属性名的驼峰映射对应到表名应该以下划线分割开，如userName属性对应的表字段名应该为user_name
* 禁止使用保留字desc 、 range 、 match 、 delayed等
* 主键索引名为 pk_字段名；唯一索引名为 uk_表名_字段名 ； 普通索引名则为 idx_表名_字段名
* 小数类型为 decimal ，禁止使用 float 和 double
      说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。
      如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储
* 库名与项目名称尽量一致
## 3.2	索引规约
* 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
	     说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的 ； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生
* 超过三个表禁止 join 。需要 join 的字段，数据类型必须绝对一致 ； 多表关联查询时，保证被关联的字段需要有索引
* 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可
* 如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file _ sort 的情况，影响查询性能
* 建组合索引的时候，区分度最高的在最左边
* 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决（建议）
* 防止因字段类型不同造成的隐式转换，导致索引失效
## 3.3	SQL语句
* 不要使用 count( 列名 ) 或 count( 常量 ) 来替代 count( * ) ， count( * ) 是 SQL 92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关
* count(distinct col) 计算该列除 NULL 之外的不重复行数，注意  count(distinc   col 1,  col 2 ) 如果其中一列全为 NULL ，那么即使另一列有不同的值，也返回为 0
* 当某一列的值全是 NULL 时， count(col) 的返回结果为 0，但 sum(col) 的返回结果为NULL ，因此使用 sum() 时需注意 NPE 问题
* 使用 ISNULL() 来判断是否为 NULL 值。注意： NULL 与任何值的直接比较都为 NULL。
      说明：
          1 ） NULL<>NULL 的返回结果是 NULL ，而不是 false 。
          2 ） NULL=NULL 的返回结果是 NULL ，而不是 true 。
          3 ） NULL<>1 的返回结果是 NULL ，而不是 true 。
* 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句
* 不得使用外键与级联，一切外键概念必须在应用层解决
* 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性数据订正时，删除和修改记录时，要先 select ，避免出现误删除，确认无误才能执行更新语句
* in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内
## 3.4	ORM映射
* 在表查询中，不建议使用 * 作为查询的字段列表，需要哪些字段必须明确写明
* 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义 ； 反过来，每一个表也必然有一个与之对应
* sql. xml 配置参数使用：#{}，# param # 不要使用${} 此种方式容易出现 SQL 注入
* 不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出（建议）
* 更新数据表记录时，必须同时更新记录对应的更新时间为当前时间
* @Transactional 事务不要滥用。事务会影响数据库的 QPS ，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。同时事务以不能直接打到service实现class上，应针对方法进行打事务
# 4	项目结构
* Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等
* Service 层:相对具体的业务逻辑服务层
* DAO 层：数据访问层，与底层 MySQL 、 Oracle 、 Hbase 进行数据交互
* 开放接口层：可直接封装 Service 方法暴露成 RPC 接口 ； 通过 Web 封装成 http 接口 ；进行网关安全控制、流量控制等
# 5	安全规约
* 隶属于用户个人的页面或者功能必须进行权限控制校验
* 用户敏感数据禁止直接展示，必须对展示数据进行脱敏（除客户明确要求显示外）
	说明：查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露
* 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库
* 禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据
* 表单、 AJAX 提交必须执行 CSRF 安全过滤
* 在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损
* 发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略
* 呈现于用户端的所有字符或者内容，应该进行敏感词过滤
